** 3321. Find X-Sum of All K-Long Subarrays II **

# Approach 1:
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        running = 0
        count = Counter()
        for i in range(min(k, len(nums))):
            count[nums[i]] += 1
            running += nums[i]
        
        top = [(y, x) for x,y in count.items()]
        heapify(top)

        bottom = [] 
        
        while len(top) > x:
            c, n = heappop(top)
            heappush(bottom, (-c, -n))
            running -= c*n
        
        answer = [running]
        
        diff = x - len(top)

        for i in range(k, len(nums)):
            ni = nums[i]
            no = nums[i-k]

            no_from_top = count[no] > top[0][0] or (count[no]==top[0][0] and no >= top[0][1])
            ni_from_top = count[ni] > top[0][0] or (count[ni]==top[0][0] and ni >= top[0][1])

            count[no] -= 1
            count[ni] += 1

            if no_from_top:
                running -= no
                if count[no]:
                    heappush(top, (count[no], no))
                else:
                    diff += 1

            elif count[no]:
                heappush(bottom, (-count[no], -no))

            if ni_from_top:
                heappush(top, (count[ni], ni))
                running += ni
            else:
                heappush(bottom, (-count[ni], -ni))

            for i in range(diff):
                while bottom and bottom[0][0] != -count[-bottom[0][1]]:
                    heappop(bottom)
                
                if bottom:
                    c, n = heappop(bottom)
                    heappush(top, (-c, -n))
                    running += c * n
                    diff -= 1

                    while bottom and bottom[0][1] == n:
                        heappop(bottom)

                else:
                    break
                
            def do_rebalance(top, bottom):
                while bottom and bottom[0][0] != -count[-bottom[0][1]]:
                    heappop(bottom)
                
                while top and top[0][0] != count[top[0][1]]:
                    heappop(top)
                
                if not bottom:
                    return False

                if top[0][0] + bottom[0][0] == 0:
                    return top[0][1] < -bottom[0][1]
                
                return top[0][0] < - bottom[0][0]

            
            while do_rebalance(top, bottom):
                c, n = heappop(bottom)
                cq, nq = -c, -n
                running += (c * n)
                heappush(top, (-c, -n))

                while bottom and bottom[0][1] == n:
                    heappop(bottom)

                c, n = heappop(top)
                running -= c * n
                heappush(bottom, (-c, -n))
                
                while top and top[0][1] == n:
                    heappop(top)
                            
            answer.append(running)
        
        return answer

# Approach 2:
from sortedcontainers import SortedList
from collections import Counter

class Solution:
    def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:
        def update(num, qty):
            nonlocal sb
            if freqs[num]:
                try:
                    small.remove([freqs[num], num])
                except:
                    big.remove([freqs[num], num])
                    sb -= freqs[num] * num
            freqs[num] += qty
            if freqs[num]:
                small.add([freqs[num], num])

        small, big = SortedList(), SortedList()
        freqs = Counter()
        sb = 0
        n = len(nums)

        answer = []
        for i in range(n):
            update(nums[i], 1)
            if i >= k:
                update(nums[i - k], -1)
            while small and len(big) < x:
                cx, num = small.pop()
                sb += cx * num
                big.add([cx, num])
            while small and small[-1] > big[0]:
                cx, num = small.pop()
                cy, y = big.pop(0)
                sb += cx*num - cy*y
                small.add([cy, y])
                big.add([cx, num])
            if i >= k - 1:
                answer.append(sb)
        return answer
