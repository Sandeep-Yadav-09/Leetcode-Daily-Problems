** 3479. Fruits Into Baskets III **

# Approach 1:
class Solution:
    def numOfUnplacedFruits(self, fruits, baskets):
        n = len(baskets)
        self.seg = [0] * (4 * n)
        self.build(baskets, 0, 0, n - 1)

        unplaced = 0
        for fruit in fruits:
            if self.seg[0] < fruit:
                unplaced += 1
            else:
                if not self.place(0, 0, n - 1, fruit):
                    unplaced += 1
        return unplaced

    def build(self, baskets, idx, l, r):
        if l == r:
            self.seg[idx] = baskets[l]
            return self.seg[idx]
        mid = (l + r) // 2
        left = self.build(baskets, 2 * idx + 1, l, mid)
        right = self.build(baskets, 2 * idx + 2, mid + 1, r)
        self.seg[idx] = max(left, right)
        return self.seg[idx]

    def place(self, idx, l, r, val):
        if self.seg[idx] < val:
            return False
        if l == r:
            self.seg[idx] = -1
            return True
        mid = (l + r) // 2
        placed = self.place(2 * idx + 1, l, mid, val)
        if not placed:
            placed = self.place(2 * idx + 2, mid + 1, r, val)
        self.seg[idx] = max(self.seg[2 * idx + 1], self.seg[2 * idx + 2])
        return placed

# Approach 2:
class SegmentTree:
  def __init__(self,arr):
    self.n=len(arr)
    self.arr=arr
    self.segment=[[-1,False] for i in range(4*self.n)]
    self.buildTree(0, self.n - 1, 0)
    self.cnt=0
  def buildTree(self,l,r,i):
    if l==r:
      self.segment[i][0]=self.arr[l]
      self.segment[i][1]=True
      return
    mid=(l+r)//2
    self.buildTree(l, mid, 2 * i + 1)
    self.buildTree(mid + 1, r, 2 * i + 2)
    self.segment[i][0] = max(self.segment[2 * i + 1][0], self.segment[2 * i + 2][0])
  
  def findminimum(self,val):
    self.getans=False
    self._findminimum(0,self.n-1,val,0)
  
  def _findminimum(self, l, r, val, i):
    if l > r or self.segment[i][0] < val or self.getans:
        return

    if l == r:
      if self.segment[i][0]>=val and self.segment[i][1]:
        self.segment[i][0]=-1
        self.segment[i][1]=False
        self.cnt += 1
        self.getans = True
      return
    mid = (l + r) // 2
    self._findminimum(l, mid, val, 2 * i + 1)
    self._findminimum(mid + 1, r, val, 2 * i + 2)
    self.segment[i][0] = max(self.segment[2 * i + 1][0], self.segment[2 * i + 2][0])
class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        n=len(fruits)
        seg=SegmentTree(baskets)
        for i in fruits:
            seg.findminimum(i)
        return n-seg.cnt
