** 3651. Minimum Cost Path with Teleportations **

# Approach 1:
class Solution:
    def minCost(self, grid: List[List[int]], k: int) -> int:
        available  = [sorted([(grid[i][j], i, j) for i in range(len(grid)) for j in range(len(grid[0]))], reverse = True) for K in range(k)]
        heap = [(0, 0, 0, 0)]
        vis = [[11 for i in range(len(grid[0]))] for j in range(len(grid))] 
        while heap:
            cost, x, y, tps = heapq.heappop(heap)
            if x == len(grid) - 1 and y == len(grid[0]) - 1:
                return cost
            if vis[x][y] <= tps:
                continue
            vis[x][y] = tps
            if x + 1 < len(grid):
                heapq.heappush(heap, (cost + grid[x + 1][y], x + 1, y, tps))
            if y + 1 < len(grid[0]):
                heapq.heappush(heap, (cost + grid[x][y + 1], x, y + 1, tps))
            while tps < k and available[tps] and available[tps][-1][0] <= grid[x][y]:
                c1, x1, y1 = available[tps].pop()
                heapq.heappush(heap, (cost, x1, y1, tps + 1))

# Approach 2:
from typing import List

class Solution:
    def minCost(self, grid: List[List[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])
        memo = {}

        def dfs(i, j, teleports_left):
            if i == m - 1 and j == n - 1:
                return 0

            if i >= m or j >= n:
                return float('inf')

            if (i, j, teleports_left) in memo:
                return memo[(i, j, teleports_left)]

            result = float('inf')

            if i + 1 < m:
                result = min(result, grid[i + 1][j] + dfs(i + 1, j, teleports_left))

            if j + 1 < n:
                result = min(result, grid[i][j + 1] + dfs(i, j + 1, teleports_left))

            if teleports_left > 0:
                for x in range(m):
                    for y in range(n):
                        if grid[x][y] <= grid[i][j]:
                            result = min(result, dfs(x, y, teleports_left - 1))

            memo[(i, j, teleports_left)] = result
            return result

        return dfs(0, 0, k)
