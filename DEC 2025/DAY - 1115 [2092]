** 2092. Find All People With Secret **

# Approach 1:
class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        meetings.sort(key=lambda x: x[2])
        parent = list(range(n))
        know = [False] * n
        know[0] = know[firstPerson] = True

        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(a, b):
            pa, pb = find(a), find(b)
            if pa != pb:
                parent[pb] = pa

        i = 0
        while i < len(meetings):
            t = meetings[i][2]
            temp = []

            j = i
            while j < len(meetings) and meetings[j][2] == t:
                union(meetings[j][0], meetings[j][1])
                temp += meetings[j][:2]
                j += 1

            for x in temp:
                if know[x]:
                    know[find(x)] = True

            for x in temp:
                know[x] |= know[find(x)]

            for x in temp:
                parent[x] = x

            i = j

        return [i for i in range(n) if know[i]]        

# Approach 2:
from collections import deque, defaultdict

class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        meetings.sort(key=lambda x: x[-1])
        knows = set([0, firstPerson])

        grouped_meetings = []
        if meetings:
            curr_time = meetings[0][2]
            curr_group = []

            for m in meetings:
                if m[2] == curr_time:
                    curr_group.append(m)
                else:
                    grouped_meetings.append(curr_group)
                    curr_time = m[2]
                    curr_group = [m]
            grouped_meetings.append(curr_group)

        for group in grouped_meetings:
            adj = defaultdict(list)
            person_in_this_group = set()

            for p1, p2, time in group:
                adj[p1].append(p2)
                adj[p2].append(p1)
                person_in_this_group.add(p1)
                person_in_this_group.add(p2)

            q = deque()
            for person in person_in_this_group:
                if person in knows:
                    q.append(person)

            while q:
                curr = q.popleft()
                for neigh in adj[curr]:
                    if neigh not in knows:
                        knows.add(neigh)
                        q.append(neigh)

        return list(knows)
