** 3578. Count Partitions With Max-Min Difference at Most K **

# Approach 1:
class Solution:
    def countPartitions(self, nums: List[int], k: int) -> int:

        left, cnt, mod_ = 0, 1, 1_000_000_007
        mnQueue, mxQueue, dp = deque(), deque(), [cnt]
        
        for rght, num in enumerate(nums):
            while mxQueue and num > nums[mxQueue[-1]]:
                mxQueue.pop()
            while mnQueue and num < nums[mnQueue[-1]]:
                mnQueue.pop()

            mxQueue.append(rght)    
            mnQueue.append(rght)

            while nums[mxQueue[0]] - nums[mnQueue[0]] > k:
                cnt-= dp[left]
                left+= 1
                
                if left > mnQueue[0]: mnQueue.popleft()
                if left > mxQueue[0]: mxQueue.popleft()

            dp.append(cnt)
            cnt*= 2
            cnt%= mod_

        return dp[-1] %mod_

# Approach 2:
from collections import deque

class Solution:
    def countPartitions(self, nums: list[int], k: int) -> int:
        n = len(nums)
        dp = [0] * (n + 1)
        p = [0] * (n + 1)
        dp[0] = 1
        p[0] = 1
        maxd = deque()
        mind = deque()
        l = 0
        for i in range(1, n+1):
            x = nums[i-1]
            while maxd and maxd[-1] < x:
                maxd.pop()
            maxd.append(x)
            while mind and mind[-1] > x:
                mind.pop()
            mind.append(x)
            while maxd[0] - mind[0] > k:
                if nums[l] == maxd[0]:
                    maxd.popleft()
                if nums[l] == mind[0]:
                    mind.popleft()
                l += 1
            dp[i] = (p[i-1] - (p[l-1] if l > 0 else 0)) % (10**9+7)
            p[i] = (p[i-1] + dp[i]) % (10**9+7)
        return dp[n]
