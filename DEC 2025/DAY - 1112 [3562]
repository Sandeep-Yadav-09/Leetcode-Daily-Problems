** 3562. Maximum Profit from Trading Stocks with Discounts **

# Approach 1:
class Solution:
    def maxProfit(self, n: int, present: List[int], future: List[int], hierarchy: List[List[int]], budget: int) -> int:
        def merge(a, b):
            c = [0] * (budget + 1)
            for i in range(budget + 1):
                best = 0
                for j in range(i + 1):
                    v = a[i - j] + b[j]
                    if v > best:
                        best = v
                c[i] = best
            return c

        g = [[] for _ in range(n)]
        for u, v in hierarchy:
            g[u - 1].append(v - 1)

        def dfs(u):
            cost = present[u]
            dcost = cost // 2

            sub0 = [0] * (budget + 1)
            sub1 = [0] * (budget + 1)
            for v in g[u]:
                c0, c1 = dfs(v)
                sub0 = merge(sub0, c0)
                sub1 = merge(sub1, c1)

            dp0 = sub0[:]  # not using discount on u
            dp1 = sub0[:]  # discount still available at u
            gain = future[u]

            for i in range(budget + 1):
                if i >= dcost:
                    dp1[i] = max(dp1[i], sub1[i - dcost] + gain - dcost)
                if i >= cost:
                    dp0[i] = max(dp0[i], sub1[i - cost] + gain - cost)
            return dp0, dp1

        return dfs(0)[0][budget]

# Approach 2:
fmax = lambda x, y: x if x > y else y

def merge(A, B):
    C = [-inf] * len(A)
    for i, a in enumerate(A):
        for j in range(len(A) - i):
            C[i + j] = fmax(C[i + j], a + B[j])
    return C

class Solution:
    def maxProfit(
        self,
        n: int,
        present: List[int],
        future: List[int],
        hierarchy: List[List[int]],
        budget: int,
    ) -> int:

        adj = [[] for _ in range(n)]
        for u, v in hierarchy:
            u -= 1
            v -= 1
            adj[u].append(v)

        def dfs(u, p):
            # res0[b] : max profit for budget b with no discount
            # res1[b] : max profit for budget b with this node discounted
            dp0 = [0] * (budget + 1)
            dp1 = [0] * (budget + 1)
            for v in adj[u]:
                if v != p:
                    res0, res1 = dfs(v, u)
                    dp0, dp1 = merge(dp0, res0), merge(dp1, res1)

            ans0 = dp0[:]
            ans1 = dp0[:]

            cost = present[u]
            for b in range(cost, budget + 1):
                ans0[b] = fmax(ans0[b], dp1[b - cost] + future[u] - cost)

            cost >>= 1
            for b in range(cost, budget + 1):
                ans1[b] = fmax(ans1[b], dp1[b - cost] + future[u] - cost)

            return ans0, ans1

        return max(dfs(0, -1)[0])
