** 1948. Delete Duplicate Folders in System **

# Approach 1:
from collections import defaultdict

class Node:
    def __init__(self, name):
        self.name = name
        self.children = {}
        self.signature = ""

class Solution:
    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        root = Node("")
        for path in paths:
            node = root
            for folder in path:
                if folder not in node.children:
                    node.children[folder] = Node(folder)
                node = node.children[folder]
        
        signature_count = defaultdict(int)
        
        def dfs(node):
            if not node.children:
                node.signature = ""
                return ""
            child_signatures = []
            for name, child in sorted(node.children.items()):
                child_signature = dfs(child)
                child_signatures.append(f"{name}({child_signature})")
            node.signature = "".join(child_signatures)
            signature_count[node.signature] += 1
            return node.signature
        
        dfs(root)
        
        result = []
        current_path = []
        
        def dfs2(node):
            if node.children and signature_count[node.signature] >= 2:
                return
            current_path.append(node.name)
            result.append(current_path.copy())
            for name, child in sorted(node.children.items()):
                dfs2(child)
            current_path.pop()
        
        for name, child in sorted(root.children.items()):
            dfs2(child)
        
        return result

# Approach 2:
class Node:
    __slots__ = ('ch','id')
    def __init__(self):
        self.ch = {}
        self.id = 0

class Solution:
    def deleteDuplicateFolder(self, paths: list[list[str]]) -> list[list[str]]:
        
        def dfs(u):
            nonlocal nxt
            items = []
            for k in sorted(u.ch):
                cid = dfs(u.ch[k])
                items.append((k,cid))
            key = tuple(items)
            if key not in idxMap:
                idxMap[key] = nxt
                nxt += 1
            u.id = idxMap[key]
            cnt[u.id] = cnt.get(u.id,0) + 1
            return u.id
            
        def collect(u, path):
            for k, v in u.ch.items():
                node = u.ch[k]
                if node.ch and cnt[node.id] > 1:
                    continue
                newp = path + [k]
                ans.append(newp)
                collect(node, newp)
        
        root = Node()
        for p in paths:
            curr = root
            for d in p:
                if d not in curr.ch:
                    curr.ch[d] = Node()
                curr = curr.ch[d]
        idxMap = {}
        cnt = {}
        nxt = 1
        
        dfs(root)
        ans = []
        collect(root, [])
        return ans
